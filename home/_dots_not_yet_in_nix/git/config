# vim: ft=gitconfig
[user]
  email = kyle@ondy.org
  name = Kyle Ondy
  # long signature of my personal gpg key
  signingkey = DB0E3C33491F91C9
[core]
  # updates to any <ref> are logged in $GIT_DIR/logs/<refs>. This information
  # can be used to determine the state of a repository at a point in history.
  logAllRefUpdates = always
[interactive]
  # when in --patch mode, take your input without having to hit enter. Greatly
  # speeds up the workflow.
  # NOTE: this requires that perl module `Term:ReadKey` is available.
  singleKey = true
[commit]
  # template containing useful directions for writing pertinent and helpful
  # commit messages.
  template = ~/.config/git/message.txt
  # signed commits don't _really_ help, because no one will ever verify them,
  # but they give a fancy 'verified' badge in gitlab and github.
  gpgSign = true
  # adding commit details to the commit message editor makes it much easier to
  # write good commit messages, along with giving convenient autocomplete
  # relating to the content of the commit.
  verbose = true
[init]
  # there is nothing of value in the template yet, but having the template
  # wired up lowers the friction when I'd like to add something.
  templatedir = ~/.config/git/template
[submodule]
  # recurse into submodules by default.
  recurse = true
[status]
  # show the number of stashes at the bottom of the status message.
  showStash = true
[color]
  # let git decide when to be colorful.
  ui = auto
[color "branch"]
  # override the default colors to be consistent despite what color scheme the
  # terminal has set. This lowers the cognitive load just a bit when quickly
  # glancing at git branch.
  current = yellow bold
  local = green bold
  remote = cyan bold
[color "diff"]
  # override the default colors to be consistent despite what color scheme the
  # terminal has set. This lowers the cognitive load just a bit when quickly
  # glancing at git diff.
  meta = yellow bold
  frag = magenta bold
  old = red bold
  new = green bold
  whitespace = red reverse
[color "status"]
  # override the default colors to be consistent despite what color scheme the
  # terminal has set. This lowers the cognitive load just a bit when quickly
  # glancing at git status.
  added = green bold
  changed = yellow bold
  untracked = red bold
[diff]
  # use "vimdiff", defined later at neovim
  tool = vimdiff
  # show prefix's during a diff that relate to the content being diffed. Helps
  # keep things straight in my head.
  mnemonicprefix = true
  # use the patience algorithm. A little slower, but more human readable
  # output.
  algorithm = patience
[difftool]
  # use "vimdiff", defined later
  tool = vimdiff
  # prompting before opening difftools is just one more key press getting in
  # the way of the groove.
  prompt = false
[merge]
  # --ff-only by default, force a command line flag to be thrown otherwise.
  # Keep the commits atomic and the history clean.
  ff = only
  # use "vimdiff", defined later
  tool = vimdiff
  # add branch description to merge commits
  branchdesc = true
  # add additional git log information to merge commit.
  log = true
  # show unmodified (original) copy of conflict along with the conflicted
  # version.
  conflictstyle = diff3
[mergetool "vimdiff"]
  # use nvim as the merge / diff tool
  cmd = nvim -d $LOCAL $REMOTE $MERGED -c '$wincmd w' -c 'wincmd J'
[push]
  # makes pushing to remotes a bit easier, not having to specify the branch
  # name if the remote has a matching name.
  default = current
  # push the local tags to the remote automagically.
  followTags = true
  # not all remotes support signed pushes. This setting should ask the remote
  # if they are supported, and respect the remote's wishes.
  gpgSign = if-asked
[pull]
  # rebase when pulling, avoid merge commits at all costs.
  rebase = true
[rebase]
  # stash any pending changes in the work directory when rebaseing, and apply
  # them when done. This can cause some strange merge conflict to be resolved
  # locally, but the convince is worth it.
  autoStash = true
  # show a diffstat of what changed since last rebase. Useful to keep track of
  # things that are changing upstream.
  stat = true
[alias]
  # show all currently configured alias, sorted.
  alias     = ! git config --global --get-regexp ^alias | sort
  # open this config file in $EDITOR for easy editing.
  ec        = config --global -e

  # the following alias are to save some keystrokes when executing common
  # commands.

  # patch add. Easiest way to keep commits small.
  ap        = add -p
  # track file, effectively staging the file without any content
  track     = add -N
  # easy way to open commit in $EDITOR
  cm        = commit
  # reword the last commit
  amend     = commit --amend
  # add staged changes to last commit, keeping that message
  forgot    = commit --amend -C HEAD
  # quickly create a commit with a message on the command line.
  cmm       = commit -m
  # show diff with words highlighted.
  wdiff     = diff --color-words
  # quickly checkout a branch.
  co        = checkout
  # quickly checkout a new branch from current HEAD
  cob       = checkout -b
  # undo the last commit.
  undo      = reset HEAD~1 --mixed
  # unstate all pending changes
  unstage   = reset HEAD .
  # status is _just_ too long to type.
  s         = status

  # these are slightly more 'complex' alias to achieve things a single command
  # doesn't.

  # edit all files that are changed in the current working directory.
  edit      = !nvim $(git diff --name-only)
  # list all local branches, sorted by last commit date.
  recent    = branch --verbose --sort=-committerdate
  # pull down latest changes and rebase against default origin. This is run
  # before starting any work on a branch.
  sync      = !git fetch --all --prune && git rebase --rebase-merges --autostash
  # add everything to a commit to comeback to later
  wip       = !git add -A && git commit -m 'WIP: savepoint via alias.'
  # like wip, but probably not coming back, reset to last commit too.
  ditch     = !git add -A && git commit -m 'TMP: Save before clean reset' && git reset HEAD~1 --hard
  # show the upstream
  upstream  = rev-parse --abbrev-ref --symbolic-full-name @{upstream}
  # Delete the remote version of the current branch
  unpublish = !git push origin :$(git branch-name)
  # get info from the git log
  lg        = log --graph --pretty=format:'%Cred%h%Creset -%G?-%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'
  # Grep the log
  loggrep   = log -E -i --grep
  # when gpg-agent crashes on me, I can recover the commit with this alias. I
  # _feel_ like there should be a better way to handle this, but it is better
  # than nothing. This is set as a shell command so no matter how deep we are
  # in the tree of this repository, the command is executed at the root on the
  # repo so our file path is always correct.
  fix-commit = ! git commit --edit --file=.git/COMMIT_EDITMSG
[gpg]
  # do not use `gpg`, always use `gpg2`.
  program = gpg2
[fetch]
  # prune automatically on fetches.
  prune = true
  # prune tags additionally when fetching.
  pruneTags = true
[credential]
  helper = store
