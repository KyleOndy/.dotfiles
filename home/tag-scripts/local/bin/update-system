#!/usr/bin/env bash
set -euo pipefail

# pretty print to the console
function _log {
  # check if stdout is a terminal...
  if test -t 1; then

    # see if it supports colors...
    ncolors=$(tput colors)

    if test -n "$ncolors" && test "$ncolors" -ge 8; then
      #bold="$(tput bold)"
      #underline="$(tput smul)"
      #standout="$(tput smso)"
      normal="$(tput sgr0)"
      #black="$(tput setaf 0)"
      #red="$(tput setaf 1)"
      green="$(tput setaf 2)"
      #yellow="$(tput setaf 3)"
      #blue="$(tput setaf 4)"
      #magenta="$(tput setaf 5)"
      #cyan="$(tput setaf 6)"
      #white="$(tput setaf 7)"
    fi
  fi

  echo "${green}### ${1} ###${normal}"
}

function _warning {
  # check if stdout is a terminal...
  if test -t 1; then

    # see if it supports colors...
    ncolors=$(tput colors)

    if test -n "$ncolors" && test "$ncolors" -ge 8; then
      normal="$(tput sgr0)"
      yellow="$(tput setaf 3)"
    fi
  fi

  echo "${yellow}### ${1} ###${normal}"
}

# keep git repos up to date.
function _pull_or_update_github {
  local repo=$1
  local destination=$2

  if [ ! -d "$destination" ]; then
    mkdir -p "$(dirname "$destination")"
    git clone https://github.com/"$repo" "$destination"
  else
    git -C "$destination" pull
  fi
}

# antigen is the ZSH plugin manager
UPDATE_ANGIGEN=
function update_antigen {
  _log "updating antigen"
  _pull_or_update_github "zsh-users/antigen" "$HOME/.config/zsh/antigen"
}

UPDATE_RBENV=
function update_rbenv {
  # rbenv
  _rbenv_path="$HOME/.rbenv"
  _log "updating rbenv"
  _pull_or_update_github rbenv/rbenv "$_rbenv_path"
  (pushd "$_rbenv_path" && src/configure && make -C src) || true

  # rubyr-build
  _log "updating ruby-build"
  mkdir -p "$_rbenv_path/plugins"
  _pull_or_update_github rbenv/ruby-build "$_rbenv_path/plugins/ruby-build"
}

INSTALL_PYENV=
function install_pyenv {
  # pyenv
  _pyenv_root="$HOME/.pyenv"
  _log "Updating pyenv"
  _pull_or_update_github "pyenv/pyenv.git" "$_pyenv_root"

  # pyenv-virtualenv
  _log "Updating pyenv-virtualenv"
  _pull_or_update_github "pyenv/pyenv-virtualenv" "$_pyenv_root/plugins/pyenv-virtualenv"
}

INSTALL_SDKMAN=
function install_sdkman {
  _warning "yet to implement."
  #curl -s "https://get.sdkman.io" | bash
}


# Update apt sources
UPDATE_SOURCES=
function update_sources {
  _log "apt update"
  sudo apt -qq update
}

# do a dist-upgrade to ensure we stay up to date.
UPDATE_PACKAGES=
function update_packages {
  _log "apt dist-upgrade"
  sudo apt -qq -y dist-upgrade
}

# remove unused packages
REMOVE_PACKAGES=
function remove_packages {
  _log "apt autoremove"
  sudo apt -qq -y autoremove
}


# Pull new updates to the dotfiles, and apply them.
UPDATE_DOTFILES=
function update_dotfiles {
  _git() {
    git --git-dir="$DOTFILES/.git" "$@"
  }
  # update dotfiles before applying them
  if [ "$(_git rev-parse --abbrev-ref HEAD)" == "master" ]; then
    _log "pulling dotfiles"
    _git pull --rebase
  else
    _warning "dotfiles are not on 'mater'. Not pulling."
  fi
}

# deploys all dotfiles to current user.
APPLY_DOTFILES=
function apply_dotfiles {
  export RCRC=~/.dotfiles/config/rcrc
  _log "applying dotfiles"
  rcup
}

# update neovims plugins
UPDATE_NVIM_PLUG=
function nvim_plug_update {
  if command -v nvim 1>/dev/null 2>&1; then
    _log "Updating nvim plug"
    nvim -c PlugUpgrade -c PlugClean -c PlugUpdate -c quitall
  else
    _warning "Could not find 'nvim'."
  fi
}

# get any new passwords
UPDATE_PASSWORDS=
function update_passwords {
  if [ "$(pass ls)" ]; then
    _log "Getting new passwords"
    pass git pull
  else
    _warning "pass does not seem to be initialized."
  fi
}

# update all the tmux plugins
UDPATE_TMUX=
function update_tmux {
  # tmux plugin manager
  _log "Updating TMux Plugin Manager"
  _pull_or_update_github "tmux-plugins/tpm" "$HOME/.tmux/plugins/tpm"

  # tmux plugins
  TPM_BIN="$HOME/.tmux/plugins/tpm/bin"
  _log "updating tmux plugins"
  "$TPM_BIN/clean_plugins"
  "$TPM_BIN/install_plugins"
  "$TPM_BIN/update_plugins" all
}

# backup my important stuff to tarsnap
RUN_TARSNAP=
function run_tarsnap_backup {
  # I had to do a little magic to get this working.
  # I installed pyenv and tarsnapper under root
  _log "Running tarsnap"
  sudo -i tarsnapper -c "$HOME/.config/tarsnap/tarsnapper.conf" make
  sudo tarsnap --print-stats
}


# this installs my default python environment
INSTALL_PYTHON=
  install_pyenv
  function install_python_with_pyenv {
    function pyenv_install {
      _log "(pyenv) installing: $1"
      pyenv install --skip-existing "$1"
    }

  _log "(pyenv) ensuring prereqs installed"
  # https://github.com/pyenv/pyenv/wiki/Common-build-problems#requirements
  sudo apt install -qq -y \
    build-essential \
    curl \
    libbz2-dev \
    libffi-dev \
    liblzma-dev \
    libncurses5-dev \
    libncursesw5-dev \
    libreadline-dev \
    libsqlite3-dev \
    libssl-dev \
    llvm \
    make \
    tk-dev \
    wget \
    xz-utils \
    zlib1g-dev

  pyenv_install 3.7.1
  pyenv_install 3.7.4
}

# apply my cron scripts
UPDATE_CRON=
function update_cron {
  _log "Applying cron jobs"
  sudo ln --force --symbolic --verbose "$DOTFILES"/cron-tasks/cron.hourly/* /etc/cron.hourly/
  sudo ln --force --symbolic --verbose "$DOTFILES"/cron-tasks/cron.daily/* /etc/cron.daily/
  sudo ln --force --symbolic --verbose "$DOTFILES"/cron-tasks/cron.weekly/* /etc/cron.weekly/
  sudo ln --force --symbolic --verbose "$DOTFILES"/cron-tasks/cron.monthly/* /etc/cron.monthly/
  bash /etc/cron.hourly/*
}

# install the packages I normally use. This is based on running debain stable.
INSTALL_MY_PACKAGES=
function install_my_packages {
  # start from a good spot
  update_sources
  update_packages

  sudo apt install -qqy \
    atop \
    build-essential \
    cowsay \
    curl \
    fortune \
    fortune-mod \
    fortune-mod \
    fortunes-debian-hints \
    git \
    gnupg2 \
    htop \
    pass \
    pcscd \
    pinentry-curses \
    scdaemon \
    tmux \
    tree \
    wget \
    zsh
}

# setup ruby env (rbenv)

# setup go env (gvm)

# setup terrafrom env (tfenv)

# setup sdk man

# setup antigen

# setup fzf


function finish {
  if [ "$?" -ne '0' ]; then
    echo "UPDATE SCRIPT FAILED!"
  fi
}

function print_help {
  echo "By default this script runs as a noop. You must expliclty throw what flags you
would like to run.

Usage:
  --apply-dotfiles      apply dotfiles to current user
  --apt-remove-packages run 'apt autoremove'
  --install-python      install pyenv and python
  --pull-new-dotfiles   get new dotfiles from upstream
  --run-tarnsap         backup to tarnsap
  --update-apt-packages run 'apt dist-upgrade'
  --update-apt-sources  run 'apt update'
  --update-cron         copy cron scripts to local cron
  --update-nvim-plugins update neovim plugins
  --update-passwords    update password store
  --install-my-packages install packages I use daily
  --update-tmux         update tmux plugins"
}

# if this is thrown, all stages are run, regardless of anyother flags.
ALL=


trap finish exit


# read args
while test $# -gt 0; do
  case "$1" in
    -h|--help)
      print_help
      exit 0
      ;;
    --run-tarnsap)
      RUN_TARSNAP=true
      shift
      ;;
    --install-python)
      INSTALL_PYTHON=true
      shift
      ;;
    --update-cron)
      UPDATE_CRON=true
      shift
      ;;
    --apply-dotfiles)
      APPLY_DOTFILES=true
      shift
      ;;
    --update-passwords)
      UPDATE_PASSWORDS=true
      shift
      ;;
    --update-tmux)
      UDPATE_TMUX=true
      shift
      ;;
    --update-apt-sources)
      UPDATE_SOURCES=true
      shift
      ;;
    --update-apt-packages)
      UPDATE_PACKAGES=true
      shift
      ;;
    --apt-rmove-packages)
      REMOVE_PACKAGES=true
      shift
      ;;
    --pull-new-dotfiles)
      UPDATE_DOTFILES=true
      shift
      ;;
    --update-nvim-plugins)
      UPDATE_NVIM_PLUG=true
      shift
      ;;
    --install-my-packages)
      INSTALL_MY_PACKAGES=true
      shift
      ;;
    --update-rbenv)
      UPDATE_RBENV=true
      shift
      ;;
    --install-pyenv)
      INSTALL_PYENV=true
      shift
      ;;
    --install-sdkman)
      INSTALL_SDKMAN=true
      shift
      ;;
    --all)
      ALL=true
      shift
      ;;
    *)
      echo "unknown flag '$1'. Exiting"
      print_help
      exit 1
      break
      ;;
  esac
done


test "$ALL" || "$INSTALL_MY_PACKAGES" && install_my_packages
test "$ALL" || "$UPDATE_SOURCES" && update_sources
test "$ALL" || "$UPDATE_PACKAGES" && update_packages
test "$ALL" || "$REMOVE_PACKAGES" && remove_packages
test "$ALL" || "$UPDATE_DOTFILES" && update_dotfiles
test "$ALL" || "$APPLY_DOTFILES" && apply_dotfiles
test "$ALL" || "$INSTALL_PYENV" && install_pyenv
test "$ALL" || "$INSTALL_PYTHON" && install_python_with_pyenv
test "$ALL" || "$UPDATE_RBENV" && update_rbenv
test "$ALL" || "$INSTALL_SDKMAN" && install_sdkman
test "$ALL" || "$UPDATE_CRON" && update_cron
test "$ALL" || "$UPDATE_PASSWORDS" && update_passwords
test "$ALL" || "$UDPATE_TMUX" && update_tmux
test "$ALL" || "$UPDATE_NVIM_PLUG" && nvim_plug_update
test "$ALL" || "$RUN_TARSNAP" && run_tarsnap_backup
true # this lets the finish block work?
